<!doctype html>
<html>
  <!-- you can edit this template -->
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Asgi dispatcher middleware</title>
    <style>
      body {
	  background: #fff;
	  color: #222;
      }
      blockquote {
	  padding: 1em;
	  background: aliceblue;
      }                              
      .container {
	  margin: 10%;
      }
      a.headerlink {
	  opacity: 0;
      }
      a.headerlink:hover {
	  opacity: 1;
      }
      pre:has(code) {
	  background: #ddd;
	  overflow: auto;
      }
      @media (prefers-color-scheme: dark) {
	  body {
	      color: #eee;
	      background: #333;
	  }

	  a {
	      color: turquoise;
	  }
	  pre:has(code) {
	      background: #222;
	  }
      }
    </style>
  </head>
  <body>
    <div class="container"><h1 id="asgi-dispatcher-middleware">ASGI dispatcher middleware<a class="headerlink" href="#asgi-dispatcher-middleware" title="Permanent link">&para;</a></h1>
<p>There is, sometimes, a scenario in which two or more different Python web frameworks have to be ran at the same location.</p>
<p>Usually one would start two different runtimes and point a reverse proxy to two different servers behind slightly different subdomains/subdirectories (paths) and call it a day.
This works for any kind of combination of HTTP servers and programming languages they are implemented in.</p>
<p>However, there are also scenarios where best course of action would be to have the exact same runtime/interpreter serve multiple different web servers.
This is also possible in a way but what if we want to go a step further and have the exact same interpreter/runtime and the exact same TCP server serve multiple different web applications implemented in multiple different codebases?</p>
<h3 id="solution">Solution<a class="headerlink" href="#solution" title="Permanent link">&para;</a></h3>
<iframe src="https://microads.ftp.sh/api/ads/delivery-node/direct?nonce=abc123  "></iframe>

<p>Enter Werkzeug Dispatcher Middleware.</p>
<p>But first, a quick detour for a primer on WSGI;</p>
<p>Python WSGI standard is a specification contract forcing web-application developers to conform to a single behavior:</p>
<ol>
<li>a web app starts with a single Python function</li>
<li>the function takes in two arguments, a request environment and a typing.Callable</li>
<li>the function uses request environment to create a response (in reality this is the application entrypoint)</li>
<li>the function calls the typing.Callable it was given with a status code and response headers</li>
<li>the function returns a typing.Iterable of response body(/ies)</li>
</ol>
<p>This means every single web application conforming to this standard works exactly the same.</p>
<p>--</p>
<p>Back to Dispatcher Middleware;</p>
<p>a dispatcher is an entrypoint, a WSGI application that passes requests through to other WSGI applications.
Remember how all WSGI applications need to conform to a specific structure? What it means is - you can dynamically decide which applications are used in which scenarios. Yes that includes Django and Flask (and probably many other combinations).</p>
<p>Werkzeug (and probably many more) packages provide this in one way or another, but for WSGI.</p>
<p>What about ASGI?</p>
<p>You will find a couple packages on Pypi addressing this case but mostly one-off packages written and maintained by one person, which might not be suitable for your requirements.</p>
<hr />
<p>Why one person? Because you can write one yourself in a 16 line function with 0 (zero) dependencies:</p>
<pre><code class="language-python">async def dispatch(scope, receive, send):                                       
    default_app = djangoapp                                                     
    patterns: dict = {&quot;/flask&quot;: flaskapp, &quot;/django&quot;: djangoapp}                       

    app = None                                                                  

    for _path, _app in patterns.items():                                        
        if not _path.startswith(scope[&quot;path&quot;]):                                 
            continue                                                            

        app = _app                                                              
        break                                                                   

    if app is None:                                                             
        app = default_app                                                       

    await app(scope, receive, send)
</code></pre>
<p>You can add as many improvements and changes to this as you'd like it's just a minimal working example and I didn't yet go into type definitions or performance improvements.</p>
<p>All credit goes to c-bata (https://github.com/c-bata, https://c-bata.medium.com/) their github gist is where I finally figured out the dots to connect: https://gist.github.com/c-bata/b77f068fc1a16e55792e8b6154dd8354</p>
<hr />
<p><a href="python-pydantic-unprintable-validationerror-object.html">[Next: a peculiar failure scenario with Pydantic 1 and how to deal with it]</a></p>
</div>
  </body>
</html>
